---
title: "GruppenAufgaben"
author: "Gruppe 26"
date: "15 2 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Libraries einbinden

```{r libraries}
if(!require(magrittr)){
  install.packages("magrittr")
}
library(magrittr)

if(!require(tidyverse)){
  install.packages("tidyverse")
}
library(tidyverse)

if(!require(readr)){
  install.packages("readr")
}
library(readr)
```



## Aufgabe 1

Importieren Sie relevante Datensätze aus dem bereitgestellten tubcloud-Ordner. Listen sie zunächst in der Dokumentation auf, welche Dateien sie importieren.

```{r import data}
### Import relevant datasets

## Import Einzelteil data sets

# Import all the relevant parts (T11, T14, T15, T16, T19, T20) which are contained in relevant Komponente sets

# read files with exotic delimiters in txt-files (T11, T16, T20) as string (for better performance)
einzelteil_t11_string <- read_file("Data/Einzelteil/Einzelteil_T11.txt")
einzelteil_t16_string <- read_file("Data/Einzelteil/Einzelteil_T16.txt")
einzelteil_t20_string <- read_file("Data/Einzelteil/Einzelteil_T20.txt")

# replace exotic delimiters between columns
einzelteil_t11_string <- gsub("\t", ",", einzelteil_t11_string)
einzelteil_t16_string <- gsub(" \\| \\| ", ",", einzelteil_t16_string)
einzelteil_t20_string <- gsub(" \\| \\| ", ",", einzelteil_t20_string)

# paste missing column name at first position to avoid parsing error when read_csv will be used
einzelteil_t11_string <- paste("X1_1", einzelteil_t11_string, sep = ",")
einzelteil_t16_string <- paste("X1_1", einzelteil_t16_string, sep = ",")
einzelteil_t20_string <- paste("X1_1", einzelteil_t20_string, sep = ",")

# replace exotic delimiters between rows with line breaks
einzelteil_t11_string <- gsub("", "\n", einzelteil_t11_string)
einzelteil_t16_string <- gsub("\t", "\n", einzelteil_t16_string)
einzelteil_t20_string <- gsub(" ", "\n", einzelteil_t20_string)

# write data into one csv file, respectively
write(einzelteil_t11_string, file = "Data/Einzelteil/Einzelteil_T11.csv")
write(einzelteil_t16_string, file = "Data/Einzelteil/Einzelteil_T16.csv")
write(einzelteil_t20_string, file = "Data/Einzelteil/Einzelteil_T20.csv")

# remove unused objects and return memory
einzelteil_t11_string <- ""
einzelteil_t16_string <- ""
einzelteil_t20_string <- ""
gc()

# Import final csv-files
# read_csv (delim = ","), coerce col_type for t16 because data is split on several columns which causes parsing errors
t11 <- read_csv("Data/Einzelteil/Einzelteil_T11.csv")
t16 <- read_csv("Data/Einzelteil/Einzelteil_T16.csv", col_types = c("nncDnnnDncDnnnDncDnnnDn"))
t19 <- read_csv("Data/Einzelteil/Einzelteil_T19.csv")
t20 <- read_csv("Data/Einzelteil/Einzelteil_T20.csv")

# read_csv2 (delim = ";"), coerce col_type for t15 because data is split on several columns which causes parsing errors
t14 <- read_csv2("Data/Einzelteil/Einzelteil_T14.csv")
t15 <- read_csv2("Data/Einzelteil/Einzelteil_T15.csv", col_types = c("nncDnnnDncDnnnDn"))


## Import Bestandteile_Komponente sets as relation tables between Komponente and Einzelteil sets

# read Bestandteile_Komponenten for relevant Kompenenten (K2LE1, K2LE2)
bestandteile_k2le1 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K2LE1.csv")
bestandteile_k2le2 <- read_csv2("Data/Komponente/Bestandteile_Komponente_K2LE2.csv")


## Import revelant Komponente datasets

# read Komponenete_K2LE1

# read file and replace delim with single character delim
tx  <- read_file("Data/Komponente/Komponente_K2LE1.txt")
tx2 <- gsub(pattern = "II", replace = ";", x = tx, fixed = TRUE)
# add column name 
tx3 <- paste("X2", tx2, sep = ";")
# replace exotic separator with newline
out <- gsub(pattern = "", replace = "\n", x = tx3, fixed = TRUE)
# write output in temp file 
myFile <- tempfile()
writeLines(out, con=myFile)

# read Komponente, remove irrevelant columns
komponente_k2le1 <- read_csv2(myFile, col_types = c("nncDnnnDncDnnnDn")) %>%
  select(-X1, -X2)

# read Komponenete_K2LE2

# read file because first column name is missing
temp1 <- read_file("Data/Komponente/Komponente_K2LE2.txt")
# add first column name
temp2 <- paste("X2", temp1, sep = "\\")
# write into temporary file
myFile2 <- tempfile()
writeLines(temp2, con=myFile2)

# read file
komponente_k2le2 <- read_delim(myFile2, delim = "\\") 

# remove unused objects and free memory
temp1 <- ""
temp2 <- ""
myFile2 <- ""
gc()


## Import Fahrzeuge und deren Bestandteile

# read Fahrzeuge, use right function for different delims (, and ;) 
fahrzeug_oem1_typ11 <- read_csv("Data/Fahrzeug/Fahrzeuge_OEM1_Typ11.csv")
fahrzeug_oem1_typ12 <- read_csv2("Data/Fahrzeug/Fahrzeuge_OEM1_Typ12.csv")
fahrzeug_oem2_typ21 <- read_csv("Data/Fahrzeug/Fahrzeuge_OEM2_Typ21.csv")
fahrzeug_oem2_typ22 <- read_csv2("Data/Fahrzeug/Fahrzeuge_OEM2_Typ22.csv")

# read Bestandteile_Fahrzeuge
bestandteile_oem1_typ11 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ11.csv")
bestandteile_oem1_typ12 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ12.csv")
bestandteile_oem2_typ21 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM2_Typ21.csv")
bestandteile_oem2_typ22 <- read_csv2("Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM2_Typ22.csv")


## Import Zulassungen and Geodaten

# read zulassungen
zulassungen <- read_csv2("Data/Zulassungen/Zulassungen_alle_Fahrzeuge.csv")


## Import der Geodaten
# Tier1, Tier2, OEM-Werke, Gemeinden
# Schwierigkeiten: 


# Import with readr
locale = locale(encoding = 'ISO-8859-1')
tier1 <- read_csv2("Data/Geodaten/Tier1_Werke_2017-07-11_v1.2_TrR.csv",
                   locale = locale, col_types = "ccnnn")
tier2 <- read_csv2("Data/Geodaten/Tier2_Werke_2017-07-11_v1.2_TrR.csv",
                   locale = locale, col_types = "ccnnn")
oem <- read_csv2("Data/Geodaten/OEM_Werke_2017-07-04_TrR.csv",
                   locale = locale, col_types = "ccnnn")
gemeinden <- read_csv2("Data/Geodaten/Geodaten_Gemeinden_v1.2_2017-08-22_TrR.csv", 
                   locale = locale, col_types = "__ccnn")
```

## Aufgabe 2

Bereiten Sie die für Ihre Aufgabe relevanten Daten nach den Prinzipien von tidy data auf und fügen Sie diese in einem einzigen Datensatz zusammen.

```{r tidy data}
### Tidy data

## Clean and tidy Einzelteile datasets

# Produktionsdatum_Origin_01011970 (in T11, T14, T19, T20) is an integer representing days since origin date
# Transform origin column into Class Date, use mutate to add Produktionsdatum_Origin_01011970 values to origin values
t11 <- t11 %>% 
  mutate(Produktionsdatum = as.Date(origin, format = "%d-%m-%Y") + Produktionsdatum_Origin_01011970)
t14 <- t14 %>% 
  mutate(Produktionsdatum = as.Date(origin, format = "%d-%m-%Y") + Produktionsdatum_Origin_01011970)
t19 <- t19 %>% 
  mutate(Produktionsdatum = as.Date(origin, format = "%d-%m-%Y") + Produktionsdatum_Origin_01011970)
t20 <- t20 %>% 
  mutate(Produktionsdatum = as.Date(origin, format = "%d-%m-%Y") + Produktionsdatum_Origin_01011970)

# Remove unnecessary columns
t11 <- t11 %>% select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970)
t14 <- t14 %>% select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970)
t15 <- t15 %>% select(-X1, -X1_1)
t16 <- t16 %>% select(-X1, -X1_1)
t19 <- t19 %>% select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970)
t20 <- t20 %>% select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970)

# Split the three diferent parts of T15 and T16 into three data sets
t15_part1 <- filter(t15, !is.na(ID_T15.x)) 
t15_part2 <- filter(t15, !is.na(ID_T15.y))

t16_part1 <- filter(t16, !is.na(ID_T16.x)) 
t16_part2 <- filter(t16, !is.na(ID_T16.y))
t16_part3 <- filter(t16, !is.na(ID_T16))

# Remove empty column from each data set 
t15_part1 <- t15_part1[, c(-8:-14)] 
t15_part2 <- t15_part2[, c(-1:-7)]

t16_part1 <- t16_part1[, c(-8:-21)] 
t16_part2 <- t16_part2[, c(-1:-7, -15:-21)]
t16_part3 <- t16_part3[, c(-1:-14)]

# Rename column names to the same names for all parts of T15 and T16 data set respectively
colnames(t15_part2) <- c("ID_T15", "Produktionsdatum", "Herstellernummer","Werksnummer", "Fehlerhaft", "Fehlerhaft_Datum", "Fehlerhaft_Fahrleistung" )
colnames(t15_part1) <- colnames(t15_part2)

colnames(t16_part3) <- c("ID_T16", "Produktionsdatum", "Herstellernummer","Werksnummer", "Fehlerhaft", "Fehlerhaft_Datum", "Fehlerhaft_Fahrleistung" )
colnames(t16_part2) <- colnames(t16_part3)
colnames(t16_part1) <- colnames(t16_part3)

# Bind the two (or three) datasets each into one dataset, respectively
t15 <- bind_rows(t15_part1, t15_part2)

t16 <- bind_rows(t16_part1, t16_part2, t16_part3)

t15_part1 <- ""
t15_part2 <- ""
t16_part1 <- ""
t16_part2 <- ""
t16_part3 <- ""
gc()

# Move column Produktionsdatum to the last position in T15 and T16 in order to get the same structure for all datasets
t15 <- t15 %>% select(-Produktionsdatum, Produktionsdatum)
t16 <- t16 %>% select(-Produktionsdatum, Produktionsdatum)


# rename ID_* columns to ID to get common column names for all data sets and prepare for Join/Binding by adding column "Einzelteil" with distinguishable unique value 
t11 <- rename(t11, ID_Einzelteil = ID_T11) %>%
  mutate(Einzelteil="11")
t14 <- rename(t14, ID_Einzelteil = ID_T14) %>%
  mutate(Einzelteil="14")
t15 <- rename(t15, ID_Einzelteil = ID_T15) %>%
  mutate(Einzelteil="15")
t16 <- rename(t16, ID_Einzelteil = ID_T16) %>%
  mutate(Einzelteil="16")
t19 <- rename(t19, ID_Einzelteil = ID_T19) %>%
  mutate(Einzelteil="19")
t20 <- rename(t20, ID_Einzelteil = ID_T20) %>%
  mutate(Einzelteil="20")


## Clean and tidy Bestandteile_Komponente datasets (relational table between einzelteile and komponenten)

# tidy and transform: Rename "ID_*" columns to ID_Komponente in order to match with komponenten dataset and remove unnecessary columns
bestandteile_k2le1 <- bestandteile_k2le1 %>%
  select(-X1) %>%
  rename(ID_Komponente = ID_K2LE1)
bestandteile_k2le2 <- bestandteile_k2le2 %>%
  select(-X1) %>%
  rename(ID_Komponente = ID_K2LE2)

# Each "Komponente" (k2le1 & k2le2) consist of three parts (t11, t14, t15 & t16, t19, t20): Split into three different tables resepectively and rename "ID_T*" columns into "ID_Einzelteil"
b_k2le1_part1 <- bestandteile_k2le1[, -2:-3] %>%
  rename(ID_Einzelteil = ID_T11)
b_k2le1_part2 <- bestandteile_k2le1[, c(-1,-3)] %>%
  rename(ID_Einzelteil = ID_T14)
b_k2le1_part3 <- bestandteile_k2le1[, -1:-2] %>%
  rename(ID_Einzelteil = ID_T15)

b_k2le2_part1 <- bestandteile_k2le2[, -2:-3]%>%
  rename(ID_Einzelteil = ID_T16)
b_k2le2_part2 <- bestandteile_k2le2[, c(-1,-3)] %>%
  rename(ID_Einzelteil = ID_T19)
b_k2le2_part3 <- bestandteile_k2le2[, -1:-2] %>%
  rename(ID_Einzelteil = ID_T20)


## Clean and tidy Komponente datasets

# variables in komponente_k2le1 are split into two parts,  split table in two (x and y)
komponente_k2le1.x <- komponente_k2le1 %>%
  select(1:7) %>%
  # filter out those where ID is na
  filter(!is.na(ID_Sitze.x)) %>%
  rename(
    ID_Komponente = ID_Sitze.x,
    Produktionsdatum = Produktionsdatum.x,
    Herstellernummer = Herstellernummer.x,
    Werksnummer = Werksnummer.x,
    Fehlerhaft = Fehlerhaft.x,
    Fehlerhaft_Datum = Fehlerhaft_Datum.x,
    Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung.x
  )

komponente_k2le1.y <- komponente_k2le1 %>%
  select(8:14) %>%
  # filter out those where ID is na
  filter(!is.na(ID_Sitze.y)) %>%
  rename(
    ID_Komponente = ID_Sitze.y,
    Produktionsdatum = Produktionsdatum.y,
    Herstellernummer = Herstellernummer.y,
    Werksnummer = Werksnummer.y,
    Fehlerhaft = Fehlerhaft.y,
    Fehlerhaft_Datum = Fehlerhaft_Datum.y,
    Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung.y
  )

# bind the two tables (x and y) together again the right way
komponente_k2le1 <- bind_rows(komponente_k2le1.x, komponente_k2le1.y) %>%
  mutate(Komponente = "K2LE1")

# remove unused objects and free memory
komponente_k2le1.x <- ""
komponente_k2le1.y <- ""
tx <- ""
tx2 <- ""
tx3 <- ""
out <- ""
myFile <- ""
gc()

# clean komponente_k2le2
komponente_k2le2 <- komponente_k2le2 %>%
  # format origin in date format and create Produktionsdatum, remove unnecessary columns, rename ID_Sitze column and add Komponente column to distingiush dataset later when joined
  mutate(origin = as.Date(origin, format = "%d-%m-%Y"), Produktionsdatum = as.Date(Produktionsdatum_Origin_01011970, origin = origin)) %>%
  select(-X1, ID_Komponente = ID_Sitze, -X2, -origin, -Produktionsdatum_Origin_01011970) %>%
  mutate(Komponente = "K2LE2")


## Tidy and clean Fahrzeug datasets

# deselect unnecessary columns and mutate a type column for a later check
# transform origin in date format and create Produktionsdatum
fahrzeug_oem1_typ11 <- fahrzeug_oem1_typ11 %>%
  select(-X1, -X1_1) %>%
  mutate(Fahrzeugtyp = 11)
fahrzeug_oem1_typ12 <- fahrzeug_oem1_typ12 %>%
  select(-X1, -X1_1) %>%
  mutate(Fahrzeugtyp = 12)
fahrzeug_oem2_typ21 <- fahrzeug_oem2_typ21 %>%
  mutate(origin = (as.Date(origin, format = "%d-%m-%Y")), Produktionsdatum = as.Date(Produktionsdatum_Origin_01011970, origin = origin)) %>%
  select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970) %>%
  mutate(Fahrzeugtyp = 21)
fahrzeug_oem2_typ22 <- fahrzeug_oem2_typ22 %>%
  mutate(origin = (as.Date(origin, format = "%d-%m-%Y")), Produktionsdatum = as.Date(Produktionsdatum_Origin_01011970, origin = origin)) %>%
  select(-X1, -X1_1, -origin, -Produktionsdatum_Origin_01011970) %>%
  mutate(Fahrzeugtyp = 22)


## Clean Bestandteile_Fahrzeug dataset

# select and rename columns
bestandteile_oem1_typ11 <- bestandteile_oem1_typ11 %>%
  select(ID_Komponente = ID_Sitze, ID_Fahrzeug)
bestandteile_oem1_typ12 <- bestandteile_oem1_typ12 %>%
  select(ID_Komponente = ID_Sitze, ID_Fahrzeug)
bestandteile_oem2_typ21 <- bestandteile_oem2_typ21 %>%
  select(ID_Komponente = ID_Sitze, ID_Fahrzeug)
bestandteile_oem2_typ22 <- bestandteile_oem2_typ22 %>%
  select(ID_Komponente = ID_Sitze, ID_Fahrzeug)


## Clean and tidy Zulassungen

# Clean ID from NA and rename columns in zulassungen
zulassungen <- zulassungen %>%
  drop_na(IDNummer) %>%
  select(ID_Fahrzeug = IDNummer, Gemeinde = Gemeinden, Zulassungsdatum = Zulassung)


## Clean and tidy Geodaten

## Besondere Anforderungen an die Daten:
# - Koordinaten sollen vom Typ double sein um sie anschließend in der App von leaflet in der Kartendarstellung anzuzeigen. 
# - Postleitzahlen sollen 5 Zeichen und alle Gemeinden Deutschlands beinhalten.

# Nach dem Import mit read_csv2() werden die Umlaute korrigiert und Postleitzahlen in PLZ umbenannt.

# Change ae to ä in Längengrad
colnames(tier1)[5] <- "Längengrad"
colnames(tier2)[5] <- "Längengrad"
colnames(oem)[5] <- "Längengrad"
colnames(gemeinden)[3] <- "Längengrad"
# Change Postleitzahl to PLZ
colnames(gemeinden)[1] <- "PLZ"

### Geodaten Gemeinden: gemeinden_clean
# Als nächstes werden die Postleitzahlen  normiert.

# Function that add leading zero to PLZ
addLeadingZero <- function(char) {
  ifelse(nchar(char) < 5, char <- paste0("0",char), char)
    return(char) }

# Add leading zero to PLZ if missing
gemeinden <- gemeinden %>%
  rowwise() %>%
  mutate(PLZ = addLeadingZero(PLZ))

# Dann werden fehlende Einträge hinzugefügt
# After final join in the end missing coordinates and PLZ for location "Seeg" were detected.
# Data was missing in gemeinden dataset: Add missing data as row to gemeinden dataframe
gemeinden_clean <- rbind(gemeinden, list("87637", "SEEG", 10.610416, 47.654222))
str(gemeinden_clean)

### Geodaten Werke: tier1_clean, tier2_clean
# Zuletzt werden leere Spalten gelöscht, die Koordinaten normiert und Spaltennamen geändert.

# Function that add zeros at the end of the number until it has 8 digits
addZerosUntil8Digits <- function(num) {
  for (i in 1:7) { ifelse(nchar(trunc(num)) < 8, num <- num*10, num) }
    return(num) }

# Clean: omit NAs, standardize geodata and change column names
tier1_clean <- tier1  %>%
  na.omit(tier1)  %>%
  rowwise() %>%
  mutate(Breitengrad = addZerosUntil8Digits(Breitengrad))  %>%
  mutate(Längengrad = addZerosUntil8Digits(Längengrad)) %>%
  mutate(Breitengrad = Breitengrad/1000000) %>%
  mutate(Längengrad = Längengrad/1000000) %>%
  rename(Werksnummer = Werk, Ort = ORT)

tier2_clean <- tier2  %>%
  na.omit(tier2)  %>%
  rowwise() %>%
  mutate(PLZ = addLeadingZero(PLZ) ) %>%
  mutate(Breitengrad = addZerosUntil8Digits(Breitengrad))  %>%
  mutate(Längengrad = addZerosUntil8Digits(Längengrad)) %>%
  mutate(Breitengrad = Breitengrad/1000000) %>%
  mutate(Längengrad = Längengrad/1000000) %>%
  rename(Werksnummer = Werk, Ort = ORT)
```


```{r join data}

### Join

## Join Einzelteil datasets into one

# use bind_rows(), seperate values in ID_Einzelteil column and test if it matches with the values of other columns
all_einzelteile <- bind_rows(t11, t14, t15, t16, t19, t20) %>%
  mutate(id_richtig_einzel =
           isTRUE(
              #check if ID-Herstellernr and Herstellernr match
              strsplit(ID_Einzelteil, split = "-", fixed = TRUE)[[1]][2] == Herstellernummer && 
              #check if ID-Werksnr and Werksnr match
              strsplit(ID_Einzelteil, split = "-", fixed = TRUE)[[1]][3] == Werksnummer &&
              #check if Herstellernr and Herstellernr in Werksnr match
              Herstellernummer == as.numeric(substring(Werksnummer, 1, nchar(Herstellernummer))) &&
              #check if ID-Einzelteil and Einzelteil match
              strsplit(ID_Einzelteil, split = "-", fixed = TRUE)[[1]][1] == Einzelteil
            )
  )

# if all IDs are correct, delete redundant columns
if(all(all_einzelteile$id_richtig_einzel == TRUE)) {
  all_einzelteile <- all_einzelteile %>%
    select(-id_richtig_einzel, -Einzelteil)
}

# delete unused objects
t11 <- ""
t14 <- ""
t15 <- ""
t16 <- ""
t19 <- ""
t20 <- ""
gc()


## Join Bestandteile_Komponente datasets

# bind the split tables into one
bestandteile_k2le1 <- bind_rows(b_k2le1_part1, b_k2le1_part2, b_k2le1_part3)
bestandteile_k2le2 <- bind_rows(b_k2le2_part1, b_k2le2_part2, b_k2le2_part3)

# relation table for all Komponenten and Einzelteile
bestandteile_komponenten <- bind_rows(bestandteile_k2le1, bestandteile_k2le2)

# check if any values are missing in the joined dataset
if(any(is.na(bestandteile_komponenten))==TRUE) {
   filter_all(bestandteile_komponenten, any_vars(is.na(.)))
}

# remove unused objects
b_k2le1_part1 <- ""
b_k2le1_part2 <- ""
b_k2le1_part3 <- ""
b_k2le2_part1 <- ""
b_k2le2_part2 <- ""
b_k2le2_part3 <- ""
bestandteile_k2le1 <- ""
bestandteile_k2le2 <- ""
gc()


## Join Komponente data sets

# bind tables into one and check if IDs are correct
komponenten <- bind_rows(komponente_k2le1, komponente_k2le2) %>%
   mutate(id_richtig_komp =
           isTRUE(
              #check if ID-Herstellernr and Herstellernr match
              strsplit(ID_Komponente, split = "-", fixed = TRUE)[[1]][2] == Herstellernummer && 
              #check if ID-Werksnr and Werksnr match
              strsplit(ID_Komponente, split = "-", fixed = TRUE)[[1]][3] == Werksnummer &&
              #check if Herstellernr and Herstellernr in Werksnr match
              Herstellernummer == as.numeric(substring(Werksnummer, 1, nchar(Herstellernummer))) &&
              #check if ID-Komponente and Komponente match
              strsplit(ID_Komponente, split = "-", fixed = TRUE)[[1]][1] == Komponente
            )
  )

# if all IDs are correct, delete redundant columns
if(all(komponenten$id_richtig_komp == TRUE)){
  komponenten <- komponenten %>%
    select(-id_richtig_komp, -Komponente)
}

# remove unused objects and free memory
komponente_k2le1 <- ""
komponente_k2le2 <- ""
gc()


## Join Bestandteile_Fahrzeug datasets

# bind Bestandteile together in one table and check if IDs correct
fahrzeug_bestandteile <- bind_rows(bestandteile_oem1_typ11, bestandteile_oem1_typ12) %>%
  bind_rows(bestandteile_oem2_typ21) %>%
  bind_rows(bestandteile_oem2_typ22) %>%
  filter(substring(ID_Komponente, 1, 4) == "K2LE") %>%
  mutate(id_richtig_fahrz_bestandteile = isTRUE(
      #check if Herstellernr and number in Werksnummer match in ID_Komponente
      substring(ID_Komponente, 7, 9) == substring(ID_Komponente, 11, 13) &&
      #check if Herstellernr and number in Werksnummer match in ID_Fahrzeuge
      substring(ID_Fahrzeug, 4, 4) == substring(ID_Fahrzeug, 6, 6)
  ))

# if all IDs are correct, deselect redundant columns
if(all(fahrzeug_bestandteile$id_richtig_fahrz_bestandteile == TRUE)){
  fahrzeug_bestandteile <- fahrzeug_bestandteile %>%
    select(-id_richtig_fahrz_bestandteile)
}

# check if any values are missing in the joined dataset
if(any(is.na(fahrzeug_bestandteile))==TRUE) {
   filter_all(fahrzeug_bestandteile, any_vars(is.na(.)))
}

# remove unused objects and free memory
bestandteile_oem1_typ11 <- ""
bestandteile_oem1_typ12 <- ""
bestandteile_oem2_typ21 <- ""
bestandteile_oem2_typ22 <- ""
gc()


## Join Fahrzeug datasets

# bind Fahrzeug data sets by row together in one table, check if IDs are correct
all_fahrzeuge <- bind_rows(fahrzeug_oem1_typ11, fahrzeug_oem1_typ12) %>%
  bind_rows(fahrzeug_oem2_typ21) %>%
  bind_rows(fahrzeug_oem2_typ22) %>%
  mutate(id_richtig_fahrzeuge = isTRUE(
              #check if ID-Herstellernr and Herstellernr match
              substring(ID_Fahrzeug, 4, 4) == Herstellernummer && 
              #check if ID-Werksnr and Werksnr match
              substring(ID_Fahrzeug, 6, 7) == Werksnummer &&
              #check if Herstellernr and number in Werksnr match
              Herstellernummer == as.numeric(substring(Werksnummer, 1, nchar(Herstellernummer))) &&
              # check if Fahrzeug has correct type
              substring(ID_Fahrzeug, 1, 2) == Fahrzeugtyp
  ))

# if all IDs are correct, deselect redundant columns
if(all(all_fahrzeuge$id_richtig_fahrzeuge == TRUE)){
  all_fahrzeuge <- all_fahrzeuge %>%
    select(-id_richtig_fahrzeuge, -Fahrzeugtyp)
}

# remove unused objects and free memory
fahrzeug_oem1_typ11 <- ""
fahrzeug_oem1_typ12 <- ""
fahrzeug_oem2_typ21 <- ""
fahrzeug_oem2_typ22 <- ""
gc()


## Join einzelteile with relational bestandteile_komponenten dataset

# right_join to keep all relevant Komponenten (leather seats) and the related Einzelteile, transform dates in correct class and format
einzelteile <- right_join(all_einzelteile, bestandteile_komponenten, by = "ID_Einzelteil") %>%
  mutate(Produktionsdatum = as.Date(Produktionsdatum, format = "%Y-%m-%d"),
         Fehlerhaft_Datum = as.Date(Fehlerhaft_Datum, format = "%Y-%m-%d"))

# remove unused objects
all_einzelteile <- ""
bestandteile_komponenten <- ""
gc()


## Join fahrzeuge with relational fahrzeug_bestandteile dataset

# right_join to keep all fahrzeuge with leather seats, transform dates in correct format
fahrzeuge <- right_join(all_fahrzeuge, fahrzeug_bestandteile, by = "ID_Fahrzeug") %>%
  mutate(Produktionsdatum = as.Date(Produktionsdatum, format = "%Y-%m-%d"),
         Fehlerhaft_Datum = as.Date(Fehlerhaft_Datum, format = "%Y-%m-%d"))

# remove unused objects and free memory
all_fahrzeuge <- ""
fahrzeug_bestandteile <- ""
gc()


## Join datasets with Geodaten and Zulassungen

# Join einzelteile and komponenten with Geodaten to get coordinates of each manufactory ("Werk"), left join to keep all einzelteile / komponenten data and only relevant coordinates
einzelteile_geo <- left_join(einzelteile, tier2_clean, by = "Werksnummer") %>%
  select(-PLZ, -Ort)
komponenten_geo <- left_join(komponenten, tier1_clean, by = "Werksnummer") %>%
  select(-PLZ, -Ort)

# Join fahrzeuge with zulassungen and gemeinden_clean (containing coordinates), left joins to keep all fahrzeuge data and only relevant zulassungen and coordinates
fahrzeuge_geo <- left_join(fahrzeuge, zulassungen, by = "ID_Fahrzeug") %>%
  left_join(., gemeinden_clean, by = "Gemeinde")

# Clean datasets from irrelevant columns in order to prepare for final join

# remove irrevelant columns from einzelteile_geo, komponenten_geo and fahrzeuge_geo
einzelteile_clean <- einzelteile_geo %>%
  select(-Fehlerhaft_Datum, -Fehlerhaft_Fahrleistung, -Herstellernummer, -Produktionsdatum)
komponenten_clean <- komponenten_geo %>%
  select(-Fehlerhaft_Datum, -Fehlerhaft_Fahrleistung, -Produktionsdatum) %>%
  rename(Herstellernummer_Komponente = Herstellernummer)
fahrzeuge_clean <- fahrzeuge_geo %>%
  select(-Fehlerhaft_Datum, -Fehlerhaft_Fahrleistung, -Herstellernummer, -Fehlerhaft)

# check if any values are missing in the joined datasets
if(any(is.na(einzelteile_clean))==TRUE) {
  filter_all(einzelteile_clean, any_vars(is.na(.)))
}
if(any(is.na(komponenten_clean))==TRUE) {
  filter_all(komponenten_clean, any_vars(is.na(.)))
}
if(any(is.na(fahrzeuge_clean))==TRUE) {
  filter_all(fahrzeuge_clean, any_vars(is.na(.)))
  # the filtered dataset initially showed that coordinates and PLZ are missing for the location "Seeg". The PLZ is 87637, Längengrad = 10.612874 and Breitengrad = 47.654894. The entry "Seeg" was completely missing in the "gemeinden" dataset and the NA occured after joining with zulassen. The Data was added too gemeinden dataset
}


## Final join, filter and cleaning

# Final join: einzelteile_, komponenten_, and fahrzeuge_clean by ID_Komponente column
final_join <- full_join(einzelteile_clean, komponenten_clean, by = "ID_Komponente", suffix = c("_Einzelteil", "_Komponente")) %>%
  full_join(., fahrzeuge_clean, by ="ID_Komponente") %>%
  rename(Produktionsdatum_Fahrzeug = Produktionsdatum, Werksnummer_Fahrzeug = Werksnummer)

# filter for Herstellernummer_Komponente == 111 and Fehlerhaft == 1 to get faulty parts and components of seats produced by company "111"
final_filtered <- final_join %>%
  filter(Herstellernummer_Komponente == 111) %>%
  filter(Fehlerhaft_Einzelteil == 1 | Fehlerhaft_Komponente == 1) %>%
  select(-Herstellernummer_Komponente)

final_order <- final_filtered[c(1:3,5,6,4,7:11,13,12,15,14,16,18,17)]

final_joined <- final_order
str(final_joined)
```

## Aufgabe 3

Entwickeln Sie eine Shiny-App welche folgende Kriterien erfüllt:
Alle verwendeten Packages müssen auf der aktuellen R-Version lauffähig sein.
Die Applikation muss ohne weitere Anpassungen aus dem Abgabeordner gestartet werden können. Es bietet sich an, dies vor Abgabe zu testen. Die Applikation soll sich nur auf einen einzelnen, von Ihnen erstellten Datensatz beziehen.
Das Layout der Applikation soll auf die Zielgruppe angepasst sein und der Unternehmensfarbe entsprechen. Die Farbe ihres Unternehmens ist TUB-Rot. Des Weiteren soll ein Logo in das Layout integriert werden. Es kann ein eigenes Logo erstellt werden, oder das Logo vom Fachgebiet Qualitätswissenschaft verwendet werden. Passen Sie die Schriftart ihrer Applikation nach Ihren wünschen an. Eine Anpassung ist obligatorisch.

```{r shiny app}

## Die Shiny App befindet sich in der .R Datei.

# Shiny UI

# Shiny Server
getwd()
# Shiny App
runApp("Case_Study_App_26.r")
```

```{r run previous}
# profiler stats
```

## Aufgabe 4

Visualisieren Sie folgendes in der Applikation
a. Einen Graphen, der den zeitlichen Zulassungsverlauf der betroffenen Fahrzeuge in den Gemeinden darstellt. Verwenden Sie zusätzlich eine Heatmapdarstellung zur Visualisierung von Schadensschwerpunkten. Integrieren Sie Popups in die Kartendarstellung, die Informationen zu den zugelassenen Fahrzeugen enthalten.
b. Den Lieferweg (als Luftlinie) für ein betroffenes Bauteil, welches vom Benutzer ausgewählt werden kann.
c. Den Fahrzeughaltern soll es möglich sein, (bspw. über ein Suchfeld) anhand der Fahrzeug-ID zu überprüfen, ob ihr Auto betroffen ist.
d. Ihren zugrundeliegenden Datensatz als Tabelle, damit Sie Visualisiertes auch beweisen können. Denken Sie auch hier daran, nur die notwendigen Attribute anzuzeigen.

```{r plot data}
# a) Plot data 'zeitlichen Zulassungsverlauf'
ggplot()
# b) Plot data 'Lieferweg (als Luftlinie) für ein betroffenes Bauteil'
# c) ID tracker
# d) Print table
```

## Aufgabe 5

Dokumentieren Sie die Ergebnisse Ihrer Analyse in einer R Markdown Datei. Beschreiben Sie Ihren Datenanalyseprozess schrittweise und diskutieren Sie das Ergebnis anhand aussagekräftiger Graphiken aus Ihrer entwickelten App. Das Beschreiben Ihres Vorgehens dient der Nachvollziehbarkeit Ihrer Lösungsschritte. Falls es Probleme mit Ihrem R-Code gibt, kann durch die Dokumentation ein grundsätzlich richtiges Vorgehen anerkannt werden. Kommentieren Sie deshalb Ihren Code sorgfältig und beachten Sie den tidyverse Style-Guide. Erstellen Sie ein Inhaltsverzeichnis, welches im html-File eingeblendet wird und anklickbar ist. Folgende Gliederungspunkte sollen im Inhaltsverzeichnis mindestens aufgeführt werden:
Importieren der Daten Datenaufbereitung
Erstellen des finalen Datensatzes Auswertung
Ergebnis

```{r TOC}
# Table of Contents
```

## Aufgabe 6

Im Abgabeordner sollen folgende Dateien zu finden sein, XX ist mit der Gruppennummer zu ersetzen:
- Final_Data_Group_XX
- General_Tasks_Group_XX.rmd
- General_Tasks_Group_XX.html
- Case_Study_Group_XX.rmd
- Case_Study_Group_XX.html
- Case_study_App_XX.r